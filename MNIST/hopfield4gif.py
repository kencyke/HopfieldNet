"""
This code reproduces a part of mnist data
as 80 png images which differ in the bias term.

One can make a gif animation by using convert command as follows:

convert -layers optimize -loop 0 -delay 10 *.png anim.gif

Also, one can embed them in the animated form  into a beamer slide
by using animate package and animategraphics function as follows:

\animategraphics[loop,controls,width=\linewidth]{12}{}{00}{79}
"""
# -*- coding: utf-8 -*-
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import ArtistAnimation
from sklearn.datasets import fetch_mldata

import mnist
    
class HopfieldNet(object):
    
    """Fully-connected HopfieldNet
    
    This is a fully connected HopfieldNet with binary threshold units
    and recurrent interconnections.
    
    It is generated by applying outer product costruction algorithm to the train data.
    
    It holds a collective state of neurons on which its energy function is defined.

    It reconstructs something similar to the train data from the
    corrupted test data by updating synchronously.

    """

    def _initialize_params(self, train, bias):
        self.bias = bias
        self.dim = len(train[0])
        self.patterns = len(train)
        self.W = np.zeros((self.dim, self.dim))
        mean = np.sum([np.sum(t) for t in train]) / (self.patterns * self.dim)
        for i in range(self.patterns):
            t = train[i] - mean
            self.W += np.outer(t,t)
        for j in range(self.dim):
            self.W[j,j] = 0
        self.W /= self.patterns
    
    def free_energy(self, x):
        y = - x.dot(self.W).dot(x) + np.sum(x * self.bias)
        return y

    def sync_update(self, x):
        a = self.W.dot(x) - self.bias
        x = np.sign(a)
        return x

if __name__ == '__main__':
    n_patterns = 3
    n_units = 28
    err = 0.15

    train = mnist.mnist4hn(n_patterns)
    test = mnist.addnoise(train, error_rate=err)

    model = HopfieldNet()
    
    ims = []
    for b in range(80):
        predict =[]
        model._initialize_params(train, bias=b)
        for t in test:
            e = model.free_energy(t)
            t_new = model.sync_update(t)
            e = model.free_energy(t_new)
            predict.append(t_new)
        fig, ax = plt.subplots(1, len(predict), figsize=(10, 5))
        fig.suptitle('Output Data with bias term {0}'.format(b))
        for i in range(len(predict)):
            ax[i].matshow(predict[i].reshape((n_units, n_units)), cmap='gray')
            ax[i].set_xticks([])
            ax[i].set_yticks([])
        plt.savefig('{0:02d}'.format(b))
